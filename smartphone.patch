commit e5895171542f362ce7f1e5c87950245d7a6a0d1c
Author: AndroidVM builder <build@31.186.97.223>
Date:   Sun May 27 20:57:46 2012 +0400

    Imported the smartphone patch

diff --git a/saveliev/amvsim/ContainerList/ContainerListModel.cpp b/saveliev/amvsim/ContainerList/ContainerListModel.cpp
index 210ee21..950f828 100644
--- a/saveliev/amvsim/ContainerList/ContainerListModel.cpp
+++ b/saveliev/amvsim/ContainerList/ContainerListModel.cpp
@@ -31,7 +31,11 @@ QVariant ContainerListModel::data(const QModelIndex& index, int role) const
     }
 
     if (role == Qt::SizeHintRole) {
+#if defined(DESKTOP)
         return QSize(0, 50);
+#elif defined(SMARTPHONE)
+	return QSize(0, 100);
+#endif
     }
 
     return QVariant();
diff --git a/saveliev/amvsim/ContainerList/ContainerWidget.cpp b/saveliev/amvsim/ContainerList/ContainerWidget.cpp
index fabebf5..044d1df 100644
--- a/saveliev/amvsim/ContainerList/ContainerWidget.cpp
+++ b/saveliev/amvsim/ContainerList/ContainerWidget.cpp
@@ -23,12 +23,22 @@ ContainerWidget::ContainerWidget(QVariant contName, QAbstractItemModel *model,
 
     m_powerButton = new TextPowerButton();
     m_powerButton->setOff();
+#ifdef SMARTPHONE
+    m_powerButton->setFixedHeight(95);
+#endif
     QObject::connect(m_powerButton, SIGNAL(pressed()), this, SLOT(powerPressed()));
 
     m_nameLabel = new QLabel(m_contName);
+#ifdef SMARTPHONE
+    m_nameLabel->setFixedHeight(95);
+#endif
+
 
     m_switchButton = new SwitchButton();
     m_switchButton->setStoppedContainerView();
+#ifdef SMARTPHONE
+    m_switchButton->setFixedHeight(95);
+#endif
     QObject::connect(m_switchButton, SIGNAL(pressed()), this, SLOT(switchPressed()));
     
     lay->addWidget(m_powerButton);
diff --git a/saveliev/amvsim/MainWindow.cpp b/saveliev/amvsim/MainWindow.cpp
index 92e437a..d7edec9 100644
--- a/saveliev/amvsim/MainWindow.cpp
+++ b/saveliev/amvsim/MainWindow.cpp
@@ -7,14 +7,62 @@
 #include "ContainerList/ContainerWidget.h"
 #include <Dialogs/DeviceParametersDialog.h>
 
+#ifdef SMARTPHONE
+#include <QWSServer>
+#include <QThread>
+#include <QFile>
+#include <QDir>
+#include <QDebug>
+#include <QTimer>
+
+#include "SupervisorListener.h"
+#endif
+
+#ifdef SMARTPHONE
+
+static QString findBacklightControl() {
+    QDir bd("/sys/class/backlight");
+    if (bd.exists()) {
+	QString brd;
+	foreach (brd, bd.entryList()) {
+	    if (brd.startsWith(".")) {
+		continue;
+	    }
+
+	    QFile br(bd.absolutePath() + "/" + brd + "/brightness");
+	    if (br.exists()) {
+		qDebug() << "Backlight control is at " << br.fileName();
+		return br.fileName();
+	    }	    
+	}
+    } else {
+	qDebug() << "No backlight class\n";
+    }
+
+    return QString();
+}
+#endif
+
 MainWindow::MainWindow(IDevice* device, QWidget* parent)
     : QMainWindow(parent), m_device(device)
 {    
     setWindowTitle("Configurator");
+
+#if defined(DESKTOP)
+
     setWindowFlags((this->windowFlags() | Qt::CustomizeWindowHint) & ~Qt::WindowMaximizeButtonHint);
     setFixedHeight(HEIGHT);
     setFixedWidth(WIDTH);
     setStyleSheet("font-size: 13px;");
+
+#elif defined(SMARTPHONE)
+
+    bf = findBacklightControl();
+    workaroundStartupCounter = 0;
+
+    setFont(QFont("sans", 9));
+
+#endif
     
     QWidget *allWidget = new QWidget;
     allWidget->setLayout(new QVBoxLayout);
@@ -28,6 +76,19 @@ MainWindow::MainWindow(IDevice* device, QWidget* parent)
     ((QVBoxLayout*)allWidget->layout())->addWidget(buttons);
     
     setTabOrder(containersWidget, buttons);
+
+#ifdef SMARTPHONE
+    SupervisorListener* sl = new SupervisorListener();
+    connect(sl, SIGNAL(switchedToRoot()), this, SLOT(doRepaint()));
+    connect(sl, SIGNAL(phoneAdded()), this, SLOT(preventBlanking()));
+    sl->start();
+    lightUp();
+
+    QTimer* waTimer = new QTimer(this);
+    waTimer->setInterval(3000);
+    waTimer->start(3000);
+    connect(waTimer, SIGNAL(timeout()), this, SLOT(workaround()));
+#endif
 }
 
 QWidget *MainWindow::initContainerList()
@@ -46,10 +107,10 @@ QWidget *MainWindow::initContainerList()
 
 QWidget * MainWindow::initButtons()
 {
-    m_createContainerButton = new QPushButton("Create new container", this);
+    m_createContainerButton = new QPushButton("Create new\ncontainer", this);
     QObject::connect(m_createContainerButton, SIGNAL(clicked()), this, SLOT(startAddingContainer()));
     
-    m_callParametersDialogButton = new QPushButton("Change device parameters");
+    m_callParametersDialogButton = new QPushButton("Change device\nparameters");
     QObject::connect(m_callParametersDialogButton, SIGNAL(clicked()), this, SLOT(openParametersDialog()));
     
     QWidget *w = new QWidget;
@@ -73,7 +134,59 @@ void MainWindow::openParametersDialog()
 }
 
 
+#ifdef SMARTPHONE
+
+void MainWindow::doRepaint() {
+    QWSServer* s = QWSServer::instance();
+
+    if (s) {
+	s->refresh();
+    }
+
+    lightUp();
+}
+
+void MainWindow::preventBlanking() {
+    workaroundStartupCounter = 6;
+}
+
+void MainWindow::workaround() {
+    // Android startup screen blanking workaround
+
+    if (workaroundStartupCounter > 0) {
+	qDebug() << "Refreshing screen...";
+	doRepaint();
+	workaroundStartupCounter--;
+	return;
+    }
+
+    // Fix backlight
+
+    if (!bf.isEmpty()) {
+	QFile brc(bf);
+
+	if (brc.open(QIODevice::ReadWrite | QIODevice::Unbuffered)) {
+	    if (brc.read(3).toInt() == 0) {
+		qDebug() << "Turning backlight on";
+		brc.write("100");
+	    }
+	} else {
+	    qDebug() << "Failed to read " << brc.fileName();
+	}
+    }    
+}
+
+void MainWindow::lightUp() {
+    QFile brc(bf);
+
+    if (brc.open(QIODevice::WriteOnly | QIODevice::Unbuffered)) {
+	brc.write("100");
+    } else {
+	qDebug() << "Failed to write to " << brc.fileName();
+    }
+}
 
+#endif
 
 
 
diff --git a/saveliev/amvsim/MainWindow.h b/saveliev/amvsim/MainWindow.h
index 78232a7..11cdeb5 100644
--- a/saveliev/amvsim/MainWindow.h
+++ b/saveliev/amvsim/MainWindow.h
@@ -31,6 +31,20 @@ private:
     
     QWidget *initContainerList();
     QWidget *initButtons();
+
+#ifdef SMARTPHONE
+private:
+    QString bf;
+    int workaroundStartupCounter;
+
+    void lightUp();
+
+private slots:
+    void doRepaint();
+    void preventBlanking();
+    void workaround();
+#endif
+
     
 public slots:
     void startAddingContainer();
diff --git a/saveliev/amvsim/SupervisorListener.h b/saveliev/amvsim/SupervisorListener.h
new file mode 100644
index 0000000..5bb8ac0
--- /dev/null
+++ b/saveliev/amvsim/SupervisorListener.h
@@ -0,0 +1,106 @@
+#include <QThread>
+
+#include <cstdio>
+#include <cerrno>
+#include <stdint.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <linux/netlink.h>
+
+
+#include <api/supervisor.h>
+
+// ================================================================================
+
+#define __LOGE(x...) printf(x)
+
+static int init_transport(int *sock) {
+    struct sockaddr_nl nladdr;
+    int ret = 0;
+
+    *sock = socket(AF_NETLINK, SOCK_RAW, NETLINK_SUPERVISOR);
+    if (*sock < 0) {
+	__LOGE("Failed to create NETLINK socket: %s\n", strerror(errno));
+	return *sock;
+    }
+
+    /* source address */
+    nladdr.nl_family = AF_NETLINK;
+    nladdr.nl_pad = 0;
+    nladdr.nl_pid = 0;
+    nladdr.nl_groups = ANDCONT_SUPERVISOR_KERNEL_EVENT_MC_GROUP;
+    ret = bind(*sock, (struct sockaddr*)&nladdr, sizeof(nladdr));
+    if (ret) {
+	__LOGE("Failed to bind to the Netlink address: %s\n", strerror(errno));
+    }
+    return ret;
+}
+
+static andcont_msg_event_t* recv_sup_msg(int sock) {
+    static char buf[NLMSG_LENGTH(sizeof(andcont_msg_event_t))];
+
+    struct nlmsghdr* h = (struct nlmsghdr*)buf;
+
+    for (;;) {
+	int res = recv(sock, buf, sizeof(buf), 0);
+
+	if (res > 0) {
+	    break;
+	} else if (res < 0 && errno != EINTR) {
+	    __LOGE("Failed to receive a supervisor message: %s\n", strerror(errno));
+	    return NULL;
+	}
+    }
+
+    if (h->nlmsg_type != ANDCONT_SUPERVISOR_MSG_EVENT) {
+	return NULL;
+    }
+
+    return (andcont_msg_event_t*)NLMSG_DATA(h);
+}
+
+
+class SupervisorListener : public QThread {
+    Q_OBJECT
+
+public:
+    SupervisorListener() : QThread(NULL) { }
+
+protected:
+    void run() {
+	int sk;
+
+	if (init_transport(&sk) < 0) {
+	    return;
+	}
+
+	for (;;) {
+	    __LOGE("Waiting for the supervisor\n");
+
+	    andcont_msg_event_t* ev = recv_sup_msg(sk);
+
+	    __LOGE("Received a message from the supervisor\n");
+
+	    if (!ev) {
+		return;
+	    }
+
+	    if (ev->event == ANDCONT_SUPERV_EVENT_FOREGROUND_CHANGED && (size_t)ev->arg == 1) {
+		__LOGE("Switched to root\n");
+
+ 		emit switchedToRoot();
+	    }
+
+	    if (ev->event == ANDCONT_SUPERV_EVENT_PHONE_ADDED) {
+		__LOGE("Phone added\n");
+
+		emit phoneAdded();
+	    }
+	}
+    }
+
+signals:
+    void switchedToRoot();
+    void phoneAdded();
+};
diff --git a/saveliev/amvsim/amvsim-gui-mvc.pro b/saveliev/amvsim/amvsim-gui-mvc.pro
index aad675b..56e53b8 100644
--- a/saveliev/amvsim/amvsim-gui-mvc.pro
+++ b/saveliev/amvsim/amvsim-gui-mvc.pro
@@ -6,15 +6,17 @@
 
 QT       += core gui
 
-TARGET = AVMSimulator
+TARGET = avmcp
 TEMPLATE = app
 
+DEFINES += SMARTPHONE
 
 SOURCES += main.cpp\
     api/Container.cpp \
     api/AndroidDevice.cpp \
     api/Saver.cpp \
     api/Parameter.cpp \
+    api/Smartphone.cpp \
     MainWindow.cpp \
     Elements/ErrorLabel.cpp \
     Dialogs/NewContainerDialog.cpp \
@@ -44,6 +46,7 @@ HEADERS  += \
     api/Parameter.h \
     api/IContainer.h \
     api/IDevice.h \
+    api/Smartphone.h \
     MainWindow.h \
     Elements/ErrorLabel.h \
     Dialogs/NewContainerDialog.h \
@@ -59,7 +62,8 @@ HEADERS  += \
     ContainerList/ContainerListModel.h \
     ContainerList/ContainerDelegate.h \
     ContainerList/PowerButton.h \
-    ContainerList/SwitchButton.h
+    ContainerList/SwitchButton.h \
+    SupervisorListener.h
 
 OTHER_FILES += \
     device.txt \
diff --git a/saveliev/amvsim/api/Container.cpp b/saveliev/amvsim/api/Container.cpp
index 80b6b0b..d8ceb69 100644
--- a/saveliev/amvsim/api/Container.cpp
+++ b/saveliev/amvsim/api/Container.cpp
@@ -20,7 +20,7 @@ int Container::restoreImage(const std::string & imageAddress) {
     return 0;
 }
 
-const ContainerState Container::getState() const {
+ContainerState Container::getState() const {
     return m_state;
 }
 
diff --git a/saveliev/amvsim/api/Container.h b/saveliev/amvsim/api/Container.h
index 9bf2278..57e1dd2 100644
--- a/saveliev/amvsim/api/Container.h
+++ b/saveliev/amvsim/api/Container.h
@@ -8,7 +8,7 @@
 
 class Container : public IContainer {
 public:
-    virtual const ContainerState getState() const; //Maybe should change to isStarted() and isStopped()?
+    virtual ContainerState getState() const; //Maybe should change to isStarted() and isStopped()?
     virtual void setState(const ContainerState inpState); //Maybe should change to start() and stop()?
     virtual const std::string& getName() const;
     virtual const std::string& getImageAddress() const;
diff --git a/saveliev/amvsim/api/IContainer.h b/saveliev/amvsim/api/IContainer.h
index 7be5f68..54bd518 100644
--- a/saveliev/amvsim/api/IContainer.h
+++ b/saveliev/amvsim/api/IContainer.h
@@ -8,8 +8,7 @@
 
 class IContainer {
 public:
-    virtual const ContainerState getState() const = 0; //Maybe should change to isStarted() and isStopped()?
-    virtual void setState(const ContainerState inpState) = 0; //Maybe should change to start() and stop()?
+    virtual ContainerState getState() const = 0; //Maybe should change to isStarted() and isStopped()?
     virtual const std::string& getName() const = 0;
     virtual const std::string& getImageAddress() const = 0;
     virtual int restoreImage(const std::string& imageAddress) = 0;
diff --git a/saveliev/amvsim/api/Smartphone.cpp b/saveliev/amvsim/api/Smartphone.cpp
new file mode 100644
index 0000000..025f184
--- /dev/null
+++ b/saveliev/amvsim/api/Smartphone.cpp
@@ -0,0 +1,350 @@
+/* -*- c-basic-offset: 4 -*- */
+
+#include <iostream>
+
+#include <cstdlib>
+#include <cstdio>
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <dirent.h>
+#include <unistd.h>
+
+#include "Smartphone.h"
+
+#define LXCPATH "/usr/local/var/lib/lxc"
+
+// ================================================================================
+
+using std::string;
+using std::map;
+using std::pair;
+
+// ================================================================================
+
+static int spawn_and_wait(const char* args[]) {
+    int status = fork();
+    if (status == 0) {
+        exit(execvp(args[0], (char* const*)args));
+    } else if (status > 0) {
+        waitpid(status, &status, 0);
+
+        status = (WEXITSTATUS(status) == 0) ? 0 : -1;
+    }
+
+    return status;
+}
+
+// --------------------------------------------------------------------------------
+
+SmartphoneContainer::SmartphoneContainer(const string& containerName)
+    : m_name(containerName), m_state(StateStopped) { }
+
+SmartphoneContainer::~SmartphoneContainer() { }                                          
+
+int SmartphoneContainer::loadImage(const StorageDescriptor& sd) {
+    return 0;
+}
+
+int SmartphoneContainer::restoreImage(const std::string& imageAddress) {
+    return 0;
+}
+
+ContainerState SmartphoneContainer::getState() const {
+    return m_state;
+}
+
+const string& SmartphoneContainer::getName() const {
+    return m_name;
+}
+
+const string& SmartphoneContainer::getImageAddress() const {
+    return nothing;
+}
+
+int SmartphoneContainer::start() {
+    const char* v[] = { "lxc-start", "-n", m_name.c_str(), "-d", NULL };
+    int res = spawn_and_wait(v);
+
+    if (res == 0) {
+        m_state = StateRunning;
+    }
+
+    return res;
+}
+
+ContainerInfo SmartphoneContainer::info() const {
+    return ContainerInfo(m_name, "", m_state);
+}
+
+int SmartphoneContainer::switchTo() {
+    const char* v[] = { "switch_fg", m_name.c_str(), NULL };
+
+    return spawn_and_wait(v);
+}
+
+// --------------------------------------------------------------------------------
+
+Smartphone::Smartphone()
+{
+    DIR* cdir = opendir(LXCPATH);
+    if (cdir) {
+        struct dirent* d;
+        struct stat s;
+
+        while ((d = readdir(cdir))) {
+            char cpath[NAME_MAX];
+
+            snprintf(cpath, sizeof(cpath), "%s/%s/config", LXCPATH, d->d_name);
+            if (stat(cpath, &s) == 0) {
+                m_containers.insert(std::make_pair(d->d_name, new SmartphoneContainer(d->d_name)));
+            }
+        }
+    }
+}
+
+
+Smartphone::~Smartphone()
+{
+    for (ContainerMap::iterator it = m_containers.begin(); it != m_containers.end(); ++it) {
+        delete it->second;
+    }
+}
+
+SmartphoneContainer* Smartphone::getContainer(const std::string& name) {
+    ContainerMap::iterator cit = m_containers.find(name);
+    if (cit != m_containers.end()) {
+        return cit->second;
+    } else {
+        throw NoSuchContainerException(name);
+    }    
+}
+
+const SmartphoneContainer* Smartphone::getContainer(const std::string& name) const {
+    ContainerMap::const_iterator cit = m_containers.find(name);
+    if (cit != m_containers.end()) {
+        return cit->second;
+    } else {
+        throw NoSuchContainerException(name);
+    }    
+}
+
+IDevice::Result Smartphone::createContainer(const string& containerName, const StorageDescriptor& inpTemplate)
+{
+        
+    Result result = UndefinedError;
+
+    /*
+    Container * container;
+    if (m_containers.find(containerName) != this->m_containers.end()) {
+        result = IdAlreadyExists;
+    } else {
+        container = new Container(containerName);
+
+        if (container->loadImage(inpTemplate) != 0) {
+            result = CannotLoadImage;
+        } else {
+            m_containers.insert(pair<string, Container*>(containerName, container));
+
+            if (m_saver.save(m_containers) != 0) {
+                result = CannotSave;
+            } else {
+                result = Alright;
+            }
+        }
+    }
+    */
+
+    return result;
+}
+
+
+Smartphone::Result Smartphone::destroyContainer(const string & containerName)
+{
+    Result result = UndefinedError;
+
+    /*
+    map<string, Container*>::iterator containerIter = this->m_containers.find(containerName);
+
+    if (containerIter == this->m_containers.end()) {
+        result = NoSuchId;
+    } else {
+        if (this->m_activeContainer == containerIter->second) {
+            this->m_activeContainer = 0;
+        }
+        delete containerIter->second;
+        this->m_containers.erase(containerIter);
+
+        if (m_saver.save(m_containers) != 0) {
+            result = CannotSave;
+        } else {
+            result = Alright;
+        }
+    }
+    */
+
+    return result;
+}
+
+
+int Smartphone::startContainer(const string& containerName)
+{
+    return getContainer(containerName)->start();
+    
+    // map<string, Container*>::iterator containerIter = this->m_containers.find(containerName);
+    // if (containerIter != this->m_containers.end()){
+    //     containerIter->second->setState(StateRunning); //Do same stuff about starting container.
+    //     /* added by Vlad Saveliev */ if (m_activeContainer == 0) switchToContainer(containerName);
+    //     status = 0;
+    // } else {
+    //     status = -1;
+    // }
+
+}
+
+
+int Smartphone::stopContainer(const string & containerName)
+{
+    int status = 0;
+
+    /*
+    map<string, Container*>::iterator containerIter = this->m_containers.find(containerName);
+    if (containerIter != this->m_containers.end()){
+        containerIter->second->setState(StateStopped); //Do same stuff about stopping container.
+        status = 0;
+    } else {
+        status = -1;
+    }
+    */
+
+    return status;
+}
+
+
+int Smartphone::switchToContainer(const string& containerName)
+{
+    SmartphoneContainer* c = getContainer(containerName);
+
+    int status = c->switchTo();
+
+    if (status == 0) {
+        m_activeContainer = c;
+    }
+
+    /*
+    map<string, Container*>::iterator containerIter = this->m_containers.find(containerName);
+    if (containerIter != this->m_containers.end()){
+        this->m_activeContainer = containerIter->second;
+        status = 0;
+    } else {
+        status = -1;
+    }
+    */
+
+    return status;
+}
+
+
+int Smartphone::setContainerImage(const string & containerName, const StorageDescriptor & image)
+{
+    int status = 0;
+
+    /*
+    map<string, Container*>::iterator containerIter = this->m_containers.find(containerName);
+    if (containerIter != this->m_containers.end()) {
+        if (((Container*)containerIter->second)->loadImage(image) != 0)
+            status = -2;
+        else
+            status = 0;
+    } else {
+        status = -1;
+    }
+    */
+
+    return status;
+}
+
+
+int Smartphone::syncContainerImage(const string &)
+{
+    int status = 0;
+    // Do some stuff about sync.
+    return status;
+}
+
+
+//std::vector<std::string> Smartphone::getContainersNames() const
+//{
+//    std::vector<int> names;
+//    for(map<int,int>::iterator it = myContainers.begin(); it != myContainers.end(); ++it) {
+//        names.push_back(it->first);
+//        cout << it->first << "\n";
+//    }
+//    return names;
+//}
+
+
+const std::string& Smartphone::getActiveContainer() const
+{
+    return m_activeContainer->getName();
+}
+
+
+ContainerInfo Smartphone::getContainerInfo(const std::string& name) const
+{
+    return getContainer(name)->info();
+
+    /*
+    if (m_containers.find(name) != m_containers.end()) {
+        Container* cont = (Container*)(m_containers.at(name));
+     // if (cont != 0) {
+        ContainerInfo info;
+        info.name = name;
+        info.state = cont->getState();
+        return info;
+    } else {
+        throw NoSuchContainerException(name);
+    }
+    */
+
+
+    //return ContainerInfo();
+}
+
+
+std::vector<std::string> Smartphone::getContainersIds() const
+{
+    std::vector<std::string> v;
+
+    for(ContainerMap::const_iterator it = m_containers.begin(); it != m_containers.end(); ++it) {
+        v.push_back(it->first);
+    }
+
+    return v;
+}
+
+
+int Smartphone::getContainersNumber() const
+{
+    return m_containers.size();
+}
+
+void Smartphone::parameterChanged(int parameterId, Value *newValue)
+{
+}
+
+
+const std::vector<Parameter*> &Smartphone::getContainerParametersList(const std::string &contName) const
+{ 
+    return m_containerParameters;
+}
+
+const std::vector<Parameter*> &Smartphone::getDeviceParametersList() const
+{
+    return m_parameters;    
+}
+
+Value *Smartphone::getValue(const std::string& parameterId) const {
+    return NULL;
+}
diff --git a/saveliev/amvsim/api/Smartphone.h b/saveliev/amvsim/api/Smartphone.h
new file mode 100644
index 0000000..912fd56
--- /dev/null
+++ b/saveliev/amvsim/api/Smartphone.h
@@ -0,0 +1,68 @@
+/* -*- mode: c++; c-basic-offset: 4 -*- */
+
+#include "IDevice.h"
+#include "IContainer.h"
+#include "NoSuchContainerException.h"
+
+// ================================================================================
+
+class SmartphoneContainer : public IContainer {
+public:
+    SmartphoneContainer(const std::string& containerName);
+    ~SmartphoneContainer();
+
+    ContainerState getState() const;
+    const std::string& getName() const;
+    const std::string& getImageAddress() const;
+    int restoreImage(const std::string& imageAddress);
+    int loadImage(const StorageDescriptor& inpTemplate);
+
+
+    int start();
+    int switchTo();
+    ContainerInfo info() const;
+    
+private:
+    std::string m_name;
+    std::string m_imageAddress;
+    ContainerState m_state;
+
+    std::string nothing;
+};
+
+// --------------------------------------------------------------------------------
+
+class Smartphone : public IDevice {
+public:
+    Smartphone();
+    ~Smartphone();
+
+
+    Result createContainer(const std::string& containerName, const StorageDescriptor& inpTemplate);
+    Result destroyContainer(const std::string& containerName);
+    int startContainer(const std::string& containerName);
+    int stopContainer(const std::string& containerName);
+    int switchToContainer(const std::string& containerName);
+    int setContainerImage(const std::string& containerName, const StorageDescriptor& image);
+    int syncContainerImage(const std::string& containerName);
+    const std::string& getActiveContainer() const;
+    ContainerInfo getContainerInfo(const std::string& name) const;
+    std::vector<std::string> getContainersIds() const;
+    int getContainersNumber() const;
+
+    const std::vector<Parameter*> &getContainerParametersList(const std::string &contName) const;
+    const std::vector<Parameter*> &getDeviceParametersList() const;     
+    void parameterChanged(int parameterId, Value *newValue);
+    Value *getValue(const std::string& parameterId) const;
+
+private:
+    typedef std::map<std::string, SmartphoneContainer*> ContainerMap;
+
+    ContainerMap m_containers;
+    IContainer* m_activeContainer;
+    std::vector<Parameter*> m_parameters;
+    std::vector<Parameter*> m_containerParameters;
+
+    const SmartphoneContainer* getContainer(const std::string& name) const;
+    SmartphoneContainer* getContainer(const std::string& name);
+};
diff --git a/saveliev/amvsim/api/supervisor.h b/saveliev/amvsim/api/supervisor.h
new file mode 100644
index 0000000..7e4a827
--- /dev/null
+++ b/saveliev/amvsim/api/supervisor.h
@@ -0,0 +1,131 @@
+#ifndef _ANDCONT_SUPERVISOR_H
+#define _ANDCONT_SUPERVISOR_H
+
+// The Netlink interface
+
+#define NETLINK_SUPERVISOR 17             // The AndCont supervisor protocol number
+
+#define NL_MC_GROUP_MASK(group) (1 << (group-1))
+
+#define ANDCONT_SUPERVISOR_KERNEL_EVENT_MC_GROUP 1 // The phone event subscriber multicast group
+
+
+#define ANDCONT_NL_MK_TYPE(subsys, msg) (((subsys) << 8) | msg)
+#define ANDCONT_NL_SUBSYS(type) ((type) >> 8)
+
+#define ANDCONT_SUBSYS_KERNEL 1       // The message destined to/originated from the kernel supervisor
+#define ANDCONT_SUBSYS_ROUTER 2       // The message destined to the ICC router
+
+// AndCont supervisor messages
+
+#define ANDCONT_SUPERVISOR_MSG_EVENT     ANDCONT_NL_MK_TYPE(ANDCONT_SUBSYS_KERNEL, 1)
+#define ANDCONT_SUPERVISOR_MSG_EVENT_ACK ANDCONT_NL_MK_TYPE(ANDCONT_SUBSYS_KERNEL, 2)
+#define ANDCONT_SUPERVISOR_MSG_ACCESS    ANDCONT_NL_MK_TYPE(ANDCONT_SUBSYS_KERNEL, 3)
+
+// AndCont virtual container state change events
+
+enum andcont_supervisor_event_t {
+  ANDCONT_SUPERV_EVENT_PHONE_ADDED,	// The argument is ignored when received by the kernel
+  					// The argument is the container init PID when broadcast by the kernel
+
+  ANDCONT_SUPERV_EVENT_PHONE_REMOVED,   // The message is never to be sent to the kernel
+  					// The argmunet is the container init PID when broadcast by the kernel
+
+  ANDCONT_SUPERV_EVENT_FOREGROUND_CHANGED, // The argument is the init PID of the foreground container
+                                           // The argument is the same when broadcast by the kernel
+
+  ANDCONT_DRIVER_MSG                       // ???
+};
+
+typedef struct {
+  enum andcont_supervisor_event_t event;
+  void* arg;
+} andcont_msg_event_t;
+
+
+// Device access control
+
+#define DCP_TYPE_CHAR 1
+#define DCP_TYPE_BLK  2
+
+typedef struct {
+  int type;
+  dev_t dev;
+} andcont_msg_access_t;
+
+
+// ----------------------------------------------------------------------------
+// Router messages
+
+// Destination types
+
+#define DEST_KERNEL  0
+#define DEST_ROOT_NS 1
+#define DEST_CURRENT 2
+
+// The router message
+
+typedef struct {
+  pid_t dest;     // The destination container init PID
+  pid_t src_pid;  // The source PID (filled by the kernel)
+  //void* src_vc;
+  uint32_t dst_groups;
+  uint32_t type;  // The message type
+} andcont_router_msg_t;
+
+
+#ifdef __KERNEL__
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/sched.h>
+#include <linux/netlink.h>
+#include <net/sock.h>
+#include <net/net_namespace.h>
+
+#include <linux/andcont/common.h>
+
+/*============= DATA STRUCTURES ========== */
+
+struct andcont_driver_list_entry {
+  struct list_head list_entry;
+  struct andcont_driver *driver;
+};
+
+/* supervisor subsystem stores data about 
+ * all the drivers here */
+struct andcont_driver_list {
+  spinlock_t lock; /* lock for the overall list */
+  struct andcont_driver_list_entry head;
+};
+typedef struct andcont_driver_list driver_list_t;
+
+struct andcont_supervisor {
+  struct semaphore lock;
+  struct andcont_driver_list drivers;
+  struct andcont_virt_phone_list vphones;
+  struct sock *supervisor_sock;
+  struct mutex sock_lock;
+  vcid_t fg_vc;
+  unsigned int ignore_pm; //ignore power management
+};
+
+/*=========== INITIALIZERS ========== */
+/* call them before any work with datastructure */
+struct andcont_driver_list_entry* add_new_driver_list_entry(
+                                  struct andcont_supervisor *supervisor); 
+
+int andcont_init_supervisor(void);
+
+/* NO DESTRUCTORS: FOR NOW WE THINK THAT 
+ * ALL DRIVERS EXIST ALL KERNEL LIFETIME */
+
+/*============= FUNCTIONS =========== */
+unsigned int andcont_supervisor_created(void);
+struct andcont_supervisor* andcont_get_supervisor(void);
+
+#endif /* ifdef __KERNEL__ */
+
+#endif /* _ANDCONT_SUPERVISOR_H */
diff --git a/saveliev/amvsim/main.cpp b/saveliev/amvsim/main.cpp
index 2749b3c..d39b897 100644
--- a/saveliev/amvsim/main.cpp
+++ b/saveliev/amvsim/main.cpp
@@ -3,13 +3,25 @@
 
 #include "MainWindow.h"
 #include <api/AndroidDevice.h>
+#include <api/Smartphone.h>
 
 int main(int argc, char *argv[])
 {
-    IDevice* device = new AndroidDevice;
+    IDevice* device;
+
+#if defined(DESKTOP)
+    device = new AndroidDevice;
+#elif defined(SMARTPHONE)
+    device = new Smartphone;
+#endif
 
     QApplication a(argc, argv);
     MainWindow w(device);
+
+#ifdef SMARTPHONE
+    w.setWindowState(Qt::WindowFullScreen);
+#endif
+
     w.show();
     
     int res = a.exec();
